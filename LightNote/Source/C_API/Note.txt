■定義ファイルについて
・コメントは doxygen をイメージしているがそれではない点に注意。
  定義ファイルをそのまま doxygen に入れても解析できない。



・型
int
float
double
const void*
const LNChar*
LNBool
const 構造体*
列挙型

■構造体定義
・int A, B, C; のように , で区切ることはできない。

■列挙型定義
・メンバ定義の末尾は必ず , であること。
・定数値に "0x" が含まれていると Flags 属性の enum となり、C# に出力するとき [Flags] 属性を付ける。

■関数ポインタ定義

■グループ

・グループ分け (リファレンスドキュメント用)
LN_MODULE(name)
LN_MODULE_END
	-> LN_MODULE(Audio)

■クラス定義

・クラス定義
LN_CLASS(name, ...)
LN_CLASS_END
	-> LN_CLASS(Audio, RefObject)
※第2引数はBaseClass

・static クラス定義
LN_STATIC_CLASS(name, ...)
LN_CLASS_END
※C# の static クラス

・ジェネリッククラス定義
LN_GENERIC_CLASS(name, ...)
LN_CLASS_END
※自動生成しない。それぞれの言語ごとに自分で書く。


■ドキュメントコメント
クラス定義または関数定義の前に付く。

・解析対象コメント
/**
*/

・コメント - 概要
@brief		テキスト

・コメント - 引数
@param[in,out]	name : テキスト

・コメント - 戻り値
@return
※通常は使わないはず。LNResult の場合は省略可能。Maker 側で自動設定する。

・コメント - 詳細
@details	テキスト

・コメント - 継承
@extends クラス名
@extends[lang] クラス名

・コメント - 置換
@replace[lang](""from"", ""to"")
	例)
	@replace[cs,ruby](""のポインタ"", ""の参照"")
※正規表現指定可能。
※全てのコメントに適用するグローバルな設定はとりあえず Maker のコードに直接書く。

・コメント - 追記
@postscript[lang](brief) テキスト
@postscript[lang](param name) テキスト
@postscript[lang](return) テキスト
@postscript[lang](details) テキスト

・コメント - 上書き
@overwrite[lang](brief) テキスト
@overwrite[lang](param name) テキスト
@overwrite[lang](return) テキスト
@overwrite[lang](details) テキスト
	例)
	@overwrite[cs,ruby](param obj) オブジェクトへの参照


・コメント - サンプルコード
@example[lang]
@example_end


■関数宣言

#・属性 - 各言語ソースで独自オーバーライド
#LN_ATTRIBUTE(Override, ...)

・属性 - public 関数
LN_INSTANCE_API

・属性 - static 関数
LN_STATIC_API
	例)
	LUMINO_STATIC_API LNResult LNSoundListener_SetPosition(const LNVector3* position);

・属性 - internal 関数
LN_INTERNAL_API
※自動生成の対象にしない。定義ソースを include して使いたいときに使用する。

・属性 - プロパティ
LN_PROPERTY
	例)
	LUMINO_STATIC_API LUMINO_PROPERTY LNResult LNSoundListener_SetPosition(const LNVector3* position);
	LUMINO_STATIC_API LUMINO_PROPERTY LNResult LNSoundListener_GetPosition(LNVector3* position);
※"Get", "Set", "Is" で対応を自動生成する

・戻り値
LNResult または void

・関数名
LN+クラス名+_+メソッド名+オーバーロードプレフィックス
	例)
	LNSoundListener_SetPositionXYZ

・関数名 - オーバーロードプレフィックス
	XYZ 
	
・関数名 - オーバーロードプレフィックス
	"D" は double 型の実装。"D" 以外の名前が一致する関数と、メタ情報を共有する。

・仮引数 - 参照オブジェクト型 (LNHandle)
LN_HANDLE(coreClassName)
	例)LUMINO_API LNResult LNSound_Create(LN_HANDLE(coreClassName) sound, ...)

・仮引数 - ジェネリック型
LN_HANDLE_GENERIC(coreClassName, typeArg)
	例)	LUMINO_STATIC_API
		LUMINO_PROPERTY
		LNResult LNViewPane_GetLayers(
			LN_HANDLE(ViewPane) viewPane, 
			LN_HANDLE_GENERIC(ObjectList, Layer)* layers);

・仮引数 - コールバック

・仮引数 - デフォルト引数
LN_DEFAULT_ARG(value)
	例)	int volume LNOTE_DEFAULT_ARG(100)
※使用できる値は
	- 数値
	- NULL
	- LN_TRUE, LN_FALSE
	- enum 定数
	

■オプション

・オプション
/*Option
Option*/

・オプション - 無効化
@disable[lang]

・オプション - 関数のオーバーライドコード
@override[言語名]
@override_end
	例)
	@override[言語名]
	#deffunc LNAudio_PlayBGMMem fileName, ...
		sdim buf, 1024
		bload fileName, buf
		LNAudio_PlayBGMMem@(buf, filesize, volume, pitch, fadeTime);
		return
	@override_end

・オプション - クラスへの追加コード
@class_add_code[言語名]
@class_add_code_end
※クラスのオプションは LN_CLASS_END の直前に書く。

■環境依存関数
HWND を取得する関数などは LUMINO_INTERNAL_API を使用し、独自定義する。

■コールバックの実装
・前提
	バインダで virtual 関数を定義しても無駄。
	まずはコールバック関数経由しないとダメ。
	
	・event ではなく delegate を使いたいタイミングって？
		→ アルゴリズムのカスタマイズ (ソート、検索)
		→ 当然、インスタンスメンバ関数も渡したい

●C_API
	・delegate (セットできるのは1つだけ)
		typedef LNResult(*LNErrorHandler)(LNErrorCode errorCode, void* userData);
		LNResult LNException_SetErrorHandler(LNEventHandler handler, void* userData);
		
	・event (複数のハンドラをセット可能)
		typedef LNResult(*LNEventHandler)(LNHandle eventArgs, void* userData);
		LNResult LNWindow_AttachEventHandler(int eventID, LNEventHandler handler, void* userData);
		LNResult LNWindow_DetachEventHandler(int eventID, LNEventHandler handler, void* userData);	// handler と userData が一致するものを削除
	
	・event (こっちのほうがいいかも)
		typedef LNResult(*LNMouseEventHandler)(LNHandle mouseEventArgs, void* userData);
		LNResult LNWindow_AttachPreviewMouseDownHandler(LNMouseEventHandler handler, void* userData);
		LNResult LNWindow_DetachPreviewMouseDownHandler(LNMouseEventHandler handler, void* userData);
	
	・関数ポインタの引数型はプリミティブ型、列挙型と LNHandle だけにする。
	  構造体をやりだすと複雑になる。Ruby では型変換が必要とか。
		
●C# Binder
	delegate Result LNMouseEventHandler(IntPtr mouseEventArgs, IntPtr userData);
	extern static Result LNWindow_AttachPreviewMouseDownHandler(LNMouseEventHandler handler, IntPtr userData);
	extern static Result LNWindow_DetachPreviewMouseDownHandler(LNMouseEventHandler handler, IntPtr userData);

	class MouseEventArgs : RefObject
	{
		getter setter ...
	}

	delegate void MouseEventHandler(MouseEventArgs e);
	class Window : RefObject
	{
		Window()
		{
			LNWindow_AttachPreviewMouseDownHandler(OnLNPreviewMouseDown);
		}
		
		protected Result OnLNPreviewMouseDown(IntPtr mouseEventArgs, IntPtr userData)
		{
			var e = EventArgs.CreateFromHandle(mouseEventArgs);//new MouseEventArgs(mouseEventArgs);
			PreviewMouseDown(e);
		}
		
		event MouseEventHandler PreviewMouseDown;
	}

●Ruby Binder
	mark

●C++ Binder
	template<TCore, TBinder>
	class EventeWrapper
	{
		Array< Delegate01<TCore> > m_delegates;
		static LNResult StaticCallback(TCore v1, void* userData)
		{
			userData->Callback();
		}
		LNResult Callback(TCore v1)
		{
			m_delegates.foreach
			{
				Call((TBinder)v1);	// 強制変換
			};
			return ...;
		}
	}

	DelegateWrapper<ErrorCode> m_ErrorHandler;
	void Exception::SetErrorHandler(Delegate01<ErrorCode> handler)
	{
		if (!m_ErrorHandler.Inited) {
			LNException_SetErrorHandler(DelegateWrapper<ErrorCode>::StaticCallback, &m_DelegateWrapper);
			m_ErrorHandler.Inited = true;
		}
		m_ErrorHandler.Set(handler);
	}
	
	EventeWrapper<LNEventArgs*, EventArgs*> m_EventHandler;
	void Window::AttachEventHandler(Delegate01<EventArgs*> handler)
	{
		if (!m_EventHandler.Inited) {
			LNWindow_AttachEventHandler(EventeWrapper<LNEventArgs*, EventArgs*>::StaticCallback, &m_EventHandler);
			m_EventHandler.Inited = true;
		}
		m_EventHandler.Attach(handler);
	}
	void Window::DetachEventHandler(Delegate01<EventArgs*> handler)
	{
		m_EventHandler.Detach(handler);
	}

	#if 0
		DelegateWrapper m_DelegateWrapper;
		void Exception::SetErrorHandler(Delegate01<ErrorCode> handler)
		{
			// 解除
			// 設定
			m_DelegateWrapper.Delegate = handler;
			LNException_SetErrorHandler(CallbackManager::staticErrorHandler, &m_DelegateWrapper);
		}
		
		DelegateWrapper m_EventWrapper;
		void Window::AttachEventHandler(Delegate01<EventArgs*> handler)
		{
			LNWindow_AttachEventHandler
			
		}
		
		void Window::DetachEventHandler(Delegate01<EventArgs*> handler)
		{
			m_DelegateWrapper.FindUserData()
			LNWindow_DetachEventHandler
		}
		
		class CallbackManager 
		{
			// 関数ポインタを解析して自動生成 (ローカル関数でもいいかも？)
			void staticErrorHandler(ErrorCode errorCode, void* userData)
			{
				DelegateWrapper* d = (DelegateWrapper*)userData;
				d->Delegate.Call(errorCode);
			}
		}
	#endif
	
・戻り値
・例外


