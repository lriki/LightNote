//=============================================================================
//【 GameObject 】
//-----------------------------------------------------------------------------
///**
//  @file       GameObject.h
//  @brief      GameObject
//  @author     Riki
//*/
//=============================================================================

#pragma once

//-------------------------------------------------------------------------
//
//-------------------------------------------------------------------------
#include <map>
#include <string>
#include "Common.h"

//-------------------------------------------------------------------------
//
//-------------------------------------------------------------------------
namespace LNote
{
namespace Core
{
namespace Game
{

//=============================================================================
// ■ GameObject
//-----------------------------------------------------------------------------
///**
//  @brief      
//*/
//=============================================================================
class GameObject
    : public Base::ReferenceObject
{
public:

    GameObject();
    virtual ~GameObject();

public:

    /// 初期化
    virtual void onInitialize() {}

    /// フレーム更新
    virtual void onUpdate() {}

    /// 削除 (1フレーム内で全てのGameObjectを更新した後、実際に削除される直前に呼ばれる)
    virtual void onDestroy() {}

public:

    /// 初期化
    void initialize();

    /// オブジェクト削除
    void destroy() { mDestroyed = true; }

    /// オブジェクト削除判定
    bool isDestroyed() const { return mDestroyed; }

    /// コンポーネントの追加
    void addComponent( Component* component );

private:

    ComponentArray  mComponentArray;
    bool            mDestroyed;
};

//-------------------------------------------------------------------------
//
//-------------------------------------------------------------------------

} // namespace Game
} // namespace Core
} // namespace LNote


/*
■ SceneObject と GameObject って分離させる必要ある？

    
    モデルやスプライトなんかはキャラクターを表示させるため、
    ひとつの GameObject に一つ以上持たせるのが普通。

    これまで SceneObject には一応親子関係持たせてたけど、
    実際のゲームで使ってたかっていうと微妙。
    というか、使ってない。
    結局 GameObject 側でなんちゃって階層構造作って、
    SceneObj にはグローバル座標を渡してた。


    階層構造を別々で持っておくと、
    演出的な点で有利かと思ったけど…
    例えばスマブラなんかの、ステージがバックグラウンドのステージ内を
    移動しながら戦う場合かつ、場外からの攻撃がある場合なんかは
    ちょっと処理がきつくなる。
    全キャラは移動するステージ土台の子、っていうふうに
    GameObj側で階層管理する方がいろいろと処理しやすい。


    SceneObjの階層構造が必要になるのはビューポートくらいかも。


    …ということで、階層構造は両方に持たせる方向で。
    ただし、SceneObj の方はあくまでビューポートなどの補助目的。
    ゲームでメインで使うのは GameObj の階層構造。

    こうなってくると、グローバル速度とローカル速度が必要かも…。


    オブジェクトのあたり判定はグローバル空間。
    反発の速度はグローバル速度。
    攻撃などでほかのオブジェクトに与える衝撃などの速度はグローバル速度。
        でもスマブラ式だとローカルにするべきなんだよなぁ…。


    

    普通こういう構造が必要になるのは相当演出に凝るときだと思うので、
    基本的には意識しなくてOKっていうスタイルにしたい。



    ゲームってやっぱり基本的にはひとつのローカルな空間の中で展開するべきだと思う。
    GameObjはデフォルトではGameMain的なオブジェクトの子として追加する。
    もしこれ以外に、ローカルな座標空間をまたいで弾を飛ばすとかいうときは
    相手には SetGlobalVelocity() を使ったりとかユーザーの責任で気を付けてね的なスタイルで。

    というわけで、普通の setVelocity() はローカル速度で。



    …でも、そうなると今度は「エフェクト出す！」ってうときに、
    ローカル座標を渡すかグローバル座標を渡すかで混乱するかも。

    Scene の空間とは違うから、普通はグローバル座標を渡すべきだけど…。
    グローバル座標は、GameObj::update() でローカル云々を更新した後、
    階層更新、物理更新、あたり判定、位置修正等を経て決まるものだったりする。

    簡単に使えるようにするにはGameObjと同じ階層構造をScene に作らないといけない。




■ GameObj を SceneObj の派生とするのは…

    SceneObj のメンバの多さと、GameObjに直接関係ないメンバが多いことが
    改めて分かったのでナシで。
    カリングとか深度テストとかの設定はさすがに GameObjには関係なさすぎると思うので。
    ゼロってことはないけどめったに使わないだろうし…。



*/

//=============================================================================
//                              end of file
//=============================================================================